diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/.cvsignore scsilib/.cvsignore
--- scsilib.orig/.cvsignore	1969-12-31 16:00:00.000000000 -0800
+++ scsilib/.cvsignore	2004-04-05 12:00:08.000000000 -0700
@@ -0,0 +1,3 @@
+Gmake.linux
+Makefile
+rc.pp
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/DEFAULTS/Defaults.linux scsilib/DEFAULTS/Defaults.linux
--- scsilib.orig/DEFAULTS/Defaults.linux	2003-02-15 16:01:48.000000000 -0800
+++ scsilib/DEFAULTS/Defaults.linux	2004-05-17 15:46:33.000000000 -0700
@@ -18,7 +18,7 @@
 ###########################################################################
 CWARNOPTS=
 
-DEFINCDIRS=	$(SRCROOT)/include /usr/src/linux/include
+DEFINCDIRS=	$(SRCROOT)/include
 LDPATH=		-L/opt/schily/lib
 RUNPATH=	-R $(INS_BASE)/lib -R /opt/schily/lib -R $(OLIBSDIR)
 
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/export/Makefile scsilib/export/Makefile
--- scsilib.orig/export/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ scsilib/export/Makefile	2004-04-12 19:03:25.000000000 -0700
@@ -0,0 +1,46 @@
+#ident %W% %E% %Q%
+###########################################################################
+# Written 1999 by Andreas Mueller
+###########################################################################
+# Makefile for local dynamic configuration
+###########################################################################
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+###########################################################################
+SRCROOT=	..
+RULESDIR=	RULES
+include		$(SRCROOT)/$(RULESDIR)/rules.top
+###########################################################################
+
+all: clobber
+	$(LN) -s $(SRCROOT)/include libschily
+	$(LN) -s $(SRCROOT)/libscg/scg scg
+	$(LN) -s $(SRCROOT)/incs/$(OARCH)/xconfig.h xconfig.h
+	$(LN) -s $(SRCROOT)/libs/$(OARCH)/libschily.a libschily.a
+	$(LN) -s $(SRCROOT)/libs/$(OARCH)/libscg.a libscg.a 
+	$(LN) -s $(SRCROOT)/libs/$(OARCH)/librscg.a librscg.a
+
+clobber:
+	$(RM_F) -r libschily scg xconfig.h libschily.a libscg.a librscg.a
+
+distclean: clobber
+
+clean: clobber
+
+OTHERTARGETS=	install ibins depend rmdep \
+		TAGS tags rmtarget relink
+
+$(OTHERTARGETS):
+	@echo "$@: nothing to make"
+
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/libscg/scsi-linux-sg.c scsilib/libscg/scsi-linux-sg.c
--- scsilib.orig/libscg/scsi-linux-sg.c	2004-01-14 09:54:01.000000000 -0800
+++ scsilib/libscg/scsi-linux-sg.c	2004-04-29 11:17:22.000000000 -0700
@@ -65,6 +65,14 @@
 
 #if LINUX_VERSION_CODE >= 0x01031a /* <linux/scsi.h> introduced in 1.3.26 */
 #if LINUX_VERSION_CODE >= 0x020000 /* <scsi/scsi.h> introduced somewhere. */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	#define __KERNEL__
+	#include <asm/types.h>
+	#include <asm/byteorder.h>
+	#undef __KERNEL__
+#endif
+
 /* Need to fine tune the ifdef so we get the transition point right. */
 #include <scsi/scsi.h>
 #else
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/Makefile scsilib/Makefile
--- scsilib.orig/Makefile	1998-09-20 15:58:30.000000000 -0700
+++ scsilib/Makefile	2004-04-12 18:56:23.000000000 -0700
@@ -13,3 +13,13 @@
 #
 include		$(SRCROOT)/$(RULESDIR)/rules.rdi
 ###########################################################################
+
+install:
+	@
+
+check:
+
+uninstall:
+	@
+
+distclean: clean
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a31/README.cdrdao scsilib/README.cdrdao
--- scsilib.orig/README.cdrdao 1969-12-31 16:00:00.000000000 -0800
+++ scsilib/README.cdrdao       2004-06-03 18:51:10.000000000 -0700
@@ -0,0 +1,7 @@
+This is a snapshot of Joerg Schilling's SCSI library from cdrtools-2.01a31.
+
+The additional directory 'export' is used to hold some links to include
+files and built libraries for easy access by the remaining cdrdao package.
+
+It is also possible to use an installed SCSI library. See "INSTALL" in the
+main directory for more information.
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/RULES/rules1.dir scsilib/RULES/rules1.dir
--- scsilib.orig/RULES/rules1.dir	2002-10-23 10:48:08.000000000 -0700
+++ scsilib/RULES/rules1.dir	2004-04-29 17:10:44.000000000 -0700
@@ -29,14 +29,12 @@
 		list=`echo TARGETS/[0-9][0-9]* | sed -e 's;TARGETS/[0-9][0-9];;g' | sed -e 's;!@!;/;g'`;\
 	for DIR in $${list} ;							\
 	do									\
-		(								\
-		echo "	==> MAKING \"$@\" ON SUBDIRECTORY \"$(CURDIR)/$$DIR\"";\
-		if [ -d ./$$DIR -a -r ./$$DIR/Makefile ] ; then			\
-			cd ./$$DIR;"$(MAKE)" $(MAKEMACS) XARCH=$(XARCH) DIRNAME=$(CURDIR)/$$DIR $@;		\
+		echo "	==> MAKING \"$@\" ON SUBDIRECTORY \"$(CURDIR)/$$DIR\""; \
+		if [ -d ./$$DIR -a -r ./$$DIR/Makefile ] ; then		\
+			"$(MAKE)" -C ./$$DIR $(MAKEMACS) XARCH=$(XARCH) DIRNAME=$(CURDIR)/$$DIR $@ || exit -1 ; \
 		else								\
 			echo "NOTICE: Partial source ($(CURDIR)/$$DIR) missing";\
-		fi								\
-		);								\
+		fi ;								\
 	done
 
 tinfo:
diff -ru --unidirectional-new-file /home/denis/packages/cdrtools-2.01a25/TARGETS/99export scsilib/TARGETS/99export
--- scsilib.orig/TARGETS/99export	1969-12-31 16:00:00.000000000 -0800
+++ scsilib/TARGETS/99export	2003-03-01 10:53:25.000000000 -0800
@@ -0,0 +1 @@
+Export
--- scsilib/RULES/mk-gmake.id.old	2004-09-08 09:10:02.000000000 -0700
+++ scsilib/RULES/mk-gmake.id	2005-04-26 14:15:21.000000000 -0700
@@ -37,9 +37,7 @@
 
 ifndef		ARCH_DONE
 
-__gmake_warn:=	$(shell cat $(SRCROOT)/$(RULESDIR)/gmake.wrn 1>&2; sleep 5)
-
-_MACHCMD=	(mach || uname -p || true)	2> /dev/null
+_MACHCMD=	(uname -p || true)	2> /dev/null
 _ARCHCMD=	(arch || /usr/ucb/arch || true)	2> /dev/null
 
 XP_ARCH:=	$(shell $(_MACHCMD) | tr '[A-Z]' '[a-z]' | tr ', /\\()"' ',//////' | tr ',/' ',-')
--- scsilib/RULES.orig/ppc64-linux-cc.rul	1970-01-01 00:00:00.000000000 +0000
+++ scsilib/RULES/ppc64-linux-cc.rul	2004-12-23 16:02:37.343901376 +0000
@@ -0,0 +1,70 @@
+#ident "@(#)i586-linux-cc.rul	1.5 02/10/15 "
+###########################################################################
+# Written 1996 by J. Schilling
+###########################################################################
+#
+# Platform dependent MACROS for Linux
+#
+###########################################################################
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+###########################################################################
+include $(SRCROOT)/$(RULESDIR)/rules.prg
+###########################################################################
+
+CPPFLAGS=	$(CPPOPTS) $(CPPOPTX)
+CFLAGS=		$(COPTS) $(CWARNOPTS) $(COPTOPT) $(GCCOPTOPT) $(COPTX)
+
+CPPOPTS=	-I. -I$(ARCHDIR) -I$(OINCSDIR) $(INCDIRS:%=-I%) $(OSDEFS)
+COPTS=
+CWOPTS=		-Wall -Wtraditional \
+		-Wshadow -Wmissing-prototypes -Wstrict-prototypes
+COPTOPT=	-O
+KDEFINES=	-DKERNEL -D_KERNEL
+COPTDYN=	-fpic
+COPTGPROF=	-pg
+
+LIB_PREFIX=	lib
+LIB_SUFFIX=	.a
+SHL_SUFFIX=	.so.1.0
+
+#LIB_SOCKET=	-lsocket -lnsl -ldl
+LIB_SOCKET=	
+LIB_MATH=	-lm
+#LIB_KVM=	-lkvm
+LIB_KVM=	
+
+LIBS_PATH=	-L$(OLIBSDIR)
+
+LDFLAGS=	$(LDOPTS) $(LDOPTX)
+LDLIBS=		$(LIBS) $(LIBX)
+
+#LDOPTS=		$(LIBS_PATH) $(LDPATH) $(RUNPATH)
+LDOPTS=		$(LIBS_PATH) $(LDPATH)
+LDOPTDYN=	-shared -Wl,-soname,$(TARGET)
+LNDYNLIB=	@$(SYMLINK) $(TARGET) $(PTARGET_BASE).so
+
+FLOAT_OPTIONS=	
+
+CC=		@echo "	==> COMPILING \"$@\""; gcc
+LDCC=		@echo "	==> LINKING \"$@\""; gcc
+DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; gcc
+RANLIB=		@echo "	==> RANDOMIZING ARCHIVE \"$@\""; true
+ARFLAGS=	cr
+LORDER=		echo
+TSORT=		cat
+
+RMDEP=		:
+MKDEP=		@echo "	==> MAKING DEPENDENCIES \"$@\""; $(RMDEP); gcc -M
+MKDEP_OUT=
diff -ruN --recursive scsilib/RULES.orig/ppc64-linux-gcc.rul scsilib/RULES/ppc64-linux-gcc.rul
--- scsilib/RULES.orig/ppc64-linux-gcc.rul	1970-01-01 00:00:00.000000000 +0000
+++ scsilib/RULES/ppc64-linux-gcc.rul	2004-12-23 16:02:43.008978904 +0000
@@ -0,0 +1,70 @@
+#ident "@(#)i586-linux-gcc.rul	1.5 02/10/15 "
+###########################################################################
+# Written 1996 by J. Schilling
+###########################################################################
+#
+# Platform dependent MACROS for Linux
+#
+###########################################################################
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+###########################################################################
+include $(SRCROOT)/$(RULESDIR)/rules.prg
+###########################################################################
+
+CPPFLAGS=	$(CPPOPTS) $(CPPOPTX)
+CFLAGS=		$(COPTS) $(CWARNOPTS) $(COPTOPT) $(GCCOPTOPT) $(COPTX)
+
+CPPOPTS=	-I. -I$(ARCHDIR) -I$(OINCSDIR) $(INCDIRS:%=-I%) $(OSDEFS)
+COPTS=
+CWOPTS=		-Wall -Wtraditional \
+		-Wshadow -Wmissing-prototypes -Wstrict-prototypes
+COPTOPT=	-O
+KDEFINES=	-DKERNEL -D_KERNEL
+COPTDYN=	-fpic
+COPTGPROF=	-pg
+
+LIB_PREFIX=	lib
+LIB_SUFFIX=	.a
+SHL_SUFFIX=	.so.1.0
+
+#LIB_SOCKET=	-lsocket -lnsl -ldl
+LIB_SOCKET=	
+LIB_MATH=	-lm
+#LIB_KVM=	-lkvm
+LIB_KVM=	
+
+LIBS_PATH=	-L$(OLIBSDIR)
+
+LDFLAGS=	$(LDOPTS) $(LDOPTX)
+LDLIBS=		$(LIBS) $(LIBX)
+
+#LDOPTS=		$(LIBS_PATH) $(LDPATH) $(RUNPATH)
+LDOPTS=		$(LIBS_PATH) $(LDPATH)
+LDOPTDYN=	-shared -Wl,-soname,$(TARGET)
+LNDYNLIB=	@$(SYMLINK) $(TARGET) $(PTARGET_BASE).so
+
+FLOAT_OPTIONS=	
+
+CC=		@echo "	==> COMPILING \"$@\""; gcc
+LDCC=		@echo "	==> LINKING \"$@\""; gcc
+DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; gcc
+RANLIB=		@echo "	==> RANDOMIZING ARCHIVE \"$@\""; true
+ARFLAGS=	cr
+LORDER=		echo
+TSORT=		cat
+
+RMDEP=		:
+MKDEP=		@echo "	==> MAKING DEPENDENCIES \"$@\""; $(RMDEP); gcc -M
+MKDEP_OUT=
--- scsilib/libscg/scsi-linux-ata.c.scan	2005-02-05 22:45:03.422964296 +0100
+++ scsilib/libscg/scsi-linux-ata.c	2005-02-05 22:39:59.748129888 +0100
@@ -689,7 +689,7 @@ sg_amapdev(scgp, f, device, schillybus, 
 		return (FALSE);
 
 	result = lstat(device, &buf);
-	if (!result && S_ISLNK(buf.st_mode)) {
+	if (0 && !result && S_ISLNK(buf.st_mode)) {
 		result = readlink(device, tmp, LOCAL_MAX_PATH);
 		if (result > 0 && result < LOCAL_MAX_PATH) {
 			tmp[result] = '\0';
--- scsilib/libscg/scsi-linux-sg.c.scan	2004-09-22 12:57:24.313986568 +0200
+++ scsilib/libscg/scsi-linux-sg.c	2004-09-22 12:57:24.327984440 +0200
@@ -287,6 +287,8 @@
 	return (0);
 }
 
+#include <glob.h>
+
 LOCAL int
 scgo_open(scgp, device)
 	SCSI	*scgp;
@@ -301,8 +303,9 @@
 	register int	t;
 	register int	l;
 	register int	nopen = 0;
-	char		devname[64];
-		BOOL	use_ata = FALSE;
+	char		*devname;
+	BOOL	use_ata = FALSE;
+	glob_t globbuf;
 
 	if (busno >= MAX_SCG || tgt >= MAX_TGT || tlun >= MAX_LUN) {
 		errno = EINVAL;
@@ -383,103 +386,92 @@
 	 * look silly but there may be users that did boot from a SCSI hdd
 	 * and connected 4 CD/DVD writers to both IDE cables in the PC.
 	 */
-	if (use_ata) for (i = 0; i <= 25; i++) {
-		js_snprintf(devname, sizeof (devname), "/dev/hd%c", i+'a');
-					/* O_NONBLOCK is dangerous */
-		f = open(devname, O_RDWR | O_NONBLOCK);
-		if (f < 0) {
-			/*
-			 * Set up error string but let us clear it later
-			 * if at least one open succeeded.
-			 */
-			if (scgp->errstr)
-				js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '/dev/hd*'");
-			if (errno != ENOENT && errno != ENXIO && errno != ENODEV) {
+	if (use_ata) {
+		glob("/dev/hd[a-z]", GLOB_NOSORT, NULL, &globbuf);
+		
+		for (i = 0; globbuf.gl_pathv && globbuf.gl_pathv[i] != NULL ; i++) {
+			devname = globbuf.gl_pathv[i];
+			f = open(devname, O_RDWR | O_NONBLOCK);
+			if (f < 0) {
+				/*
+				 * Set up error string but let us clear it later
+				 * if at least one open succeeded.
+				 */
 				if (scgp->errstr)
 					js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '%s'", devname);
-				return (0);
-			}
-		} else {
-			int	iparm;
-
-			if (ioctl(f, SG_GET_TIMEOUT, &iparm) < 0) {
-				if (scgp->errstr)
-					js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"SCSI unsupported with '/dev/hd*'");
-				close(f);
-				continue;
+						    "Cannot open '/dev/hd*'");
+				if (errno != ENOENT && errno != ENXIO && errno != ENODEV && errno != EACCES) {
+					if (scgp->errstr)
+						js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
+							    "Cannot open '%s'", devname);
+					globfree(&globbuf);
+					return (0);
+				}
+			} else {
+				int	iparm;
+				
+				if (ioctl(f, SG_GET_TIMEOUT, &iparm) < 0) {
+					if (scgp->errstr)
+						js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
+							    "SCSI unsupported with '/dev/hd*'");
+					close(f);
+					continue;
+				}
+				sg_clearnblock(f);	/* Be very proper about this */
+				if (sg_setup(scgp, f, busno, tgt, tlun, devname[7]-'a')) {
+					globfree(&globbuf);
+					return (++nopen);
+				}
+				if (busno < 0 && tgt < 0 && tlun < 0)
+					nopen++;
 			}
-			sg_clearnblock(f);	/* Be very proper about this */
-			if (sg_setup(scgp, f, busno, tgt, tlun, i))
-				return (++nopen);
-			if (busno < 0 && tgt < 0 && tlun < 0)
-				nopen++;
 		}
+		globfree(&globbuf);
 	}
 	if (use_ata && nopen == 0)
 		return (0);
 	if (nopen > 0 && scgp->errstr)
 		scgp->errstr[0] = '\0';
 
-	if (nopen == 0) for (i = 0; i < 32; i++) {
-		js_snprintf(devname, sizeof (devname), "/dev/sg%d", i);
-					/* O_NONBLOCK is dangerous */
-		f = open(devname, O_RDWR | O_NONBLOCK);
-		if (f < 0) {
-			/*
-			 * Set up error string but let us clear it later
-			 * if at least one open succeeded.
-			 */
-			if (scgp->errstr)
-				js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '/dev/sg*'");
-			if (errno != ENOENT && errno != ENXIO && errno != ENODEV) {
+	if (nopen == 0) {
+		glob("/dev/scd[0-9]", GLOB_NOSORT, NULL, &globbuf);
+		glob("/dev/scd[0-9][0-9]", GLOB_NOSORT|GLOB_APPEND, NULL, &globbuf);
+		glob("/dev/sg[a-z]", GLOB_NOSORT|GLOB_APPEND, NULL, &globbuf);
+		glob("/dev/sg[0-9]", GLOB_NOSORT|GLOB_APPEND, NULL, &globbuf);
+		
+		for (i = 0; globbuf.gl_pathv && globbuf.gl_pathv[i] != NULL ; i++) {
+			devname = globbuf.gl_pathv[i];
+
+			f = open(devname, O_RDWR | O_NONBLOCK);
+			if (f < 0) {
+				/*
+				 * Set up error string but let us clear it later
+				 * if at least one open succeeded.
+				 */
 				if (scgp->errstr)
 					js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '%s'", devname);
-				return (0);
+						    "Cannot open '/dev/scd*'");
+				if (errno != ENOENT && errno != ENXIO && errno != ENODEV && errno != EROFS) {
+					if (scgp->errstr)
+						js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
+							    "Cannot open '%s'", devname);
+					globfree(&globbuf);
+					return (0);
+				}
+			} else {
+				sg_clearnblock(f);	/* Be very proper about this */
+				if (sg_setup(scgp, f, busno, tgt, tlun, -1)) {
+					globfree(&globbuf);
+					return (++nopen);
+				}
+				if (busno < 0 && tgt < 0 && tlun < 0)
+					nopen++;
 			}
-		} else {
-			sg_clearnblock(f);	/* Be very proper about this */
-			if (sg_setup(scgp, f, busno, tgt, tlun, -1))
-				return (++nopen);
-			if (busno < 0 && tgt < 0 && tlun < 0)
-				nopen++;
 		}
 	}
 	if (nopen > 0 && scgp->errstr)
 		scgp->errstr[0] = '\0';
 
-	if (nopen == 0) for (i = 0; i <= 25; i++) {
-		js_snprintf(devname, sizeof (devname), "/dev/sg%c", i+'a');
-					/* O_NONBLOCK is dangerous */
-		f = open(devname, O_RDWR | O_NONBLOCK);
-		if (f < 0) {
-			/*
-			 * Set up error string but let us clear it later
-			 * if at least one open succeeded.
-			 */
-			if (scgp->errstr)
-				js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '/dev/sg*'");
-			if (errno != ENOENT && errno != ENXIO && errno != ENODEV) {
-				if (scgp->errstr)
-					js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '%s'", devname);
-				return (0);
-			}
-		} else {
-			sg_clearnblock(f);	/* Be very proper about this */
-			if (sg_setup(scgp, f, busno, tgt, tlun, -1))
-				return (++nopen);
-			if (busno < 0 && tgt < 0 && tlun < 0)
-				nopen++;
-		}
-	}
-	if (nopen > 0 && scgp->errstr)
-		scgp->errstr[0] = '\0';
 
 openbydev:
 	if (device != NULL && *device != '\0') {
--- scsilib/libscg/scsi-linux-ata.c.scan	2004-06-12 12:48:12.000000000 +0200
+++ scsilib/libscg/scsi-linux-ata.c	2004-09-22 12:57:24.330983984 +0200
@@ -267,7 +267,7 @@
 			starget,
 			slun;
 
-		f = open(device, O_RDONLY | O_NONBLOCK);
+		f = open(device, O_RDWR | O_NONBLOCK);
 
 		if (f < 0) {
 			if (scgp->errstr)
@@ -283,6 +283,9 @@
 	return (nopen);
 }
 
+#include <glob.h>
+
+
 LOCAL int
 scan_internal(scgp, nopen)
 	SCSI	*scgp;
@@ -293,118 +296,62 @@
 	int	schilly_bus,
 		target,
 		lun;
-	char	device[128];
+	char	*device;
+        glob_t globbuf;
+
 	/*
 	 * try always with devfs
 	 * unfortunatelly the solution with test of existing
 	 * of '/dev/.devfsd' don't work, because it root.root 700
 	 * and i don't like run suid root
 	 */
-	BOOL	DEVFS = TRUE;
+	BOOL	DEVFS = FALSE;
 
-	if (DEVFS) {
-		for (i = 0; ; i++) {
-			sprintf(device, "/dev/cdroms/cdrom%i", i);
-			if ((f = open(device, O_RDONLY | O_NONBLOCK)) < 0) {
-				if (errno != ENOENT && errno != ENXIO && errno != ENODEV && errno != EACCES) {
-					if (scgp->debug > 4) {
-						js_fprintf((FILE *) scgp->errfile,
-						"try open(%s) return %i, errno %i, cancel\n", device, f, errno);
-					}
-					return (-2);
-				} else if (errno == ENOENT || errno == ENODEV) {
-					if (scgp->debug > 4) {
-						js_fprintf((FILE *) scgp->errfile,
-						"try open(%s) return %i, errno %i\n", device, f, errno);
-					}
-					if (0 == i) {
-						DEVFS = FALSE;
-						if (scgp->debug > 4) {
-							js_fprintf((FILE *) scgp->errfile,
-							"DEVFS not detected, continuing with old dev\n");
-						}
-					}
-					break;
-				}
+	glob("/dev/cdroms/cdrom*", 
+	     GLOB_NOSORT, 
+	     NULL, &globbuf);
+	glob("/dev/hd[a-z]", 
+	     GLOB_NOSORT|GLOB_APPEND, 
+	     NULL, &globbuf);
+	/*glob("/dev/scd*",  
+	     GLOB_NOSORT|GLOB_APPEND, 
+	     NULL, &globbuf);*/
+
+	for (i = 0; globbuf.gl_pathv && globbuf.gl_pathv[i] != NULL ; i++) {
+		device = globbuf.gl_pathv[i];
+		if ((f = open(device, O_RDWR | O_NONBLOCK)) < 0) {
+			if (errno != ENOENT && errno != ENXIO && errno != ENODEV && errno != EACCES) {
 				if (scgp->debug > 4) {
-					if (errno == EACCES) {
-						js_fprintf((FILE *) scgp->errfile,
-						"errno (EACCESS), you don't have the needed rights for %s\n",
-						device);
-					}
 					js_fprintf((FILE *) scgp->errfile,
-					"try open(%s) return %i, errno %i, trying next cdrom\n",
-					device, f, errno);
+						   "try open(%s) return %i, errno %i, cancel\n", device, f, errno);
 				}
-			} else {
-				if (scgp->debug > 4) {
+				globfree(&globbuf);
+				return (-2);
+			} 
+			if (scgp->debug > 4) {
+				if (errno == EACCES) {
 					js_fprintf((FILE *) scgp->errfile,
-					"try open(%s) return %i errno %i calling sg_mapdev(...)\n",
-					device, f, errno);
-				}
-				if (sg_amapdev(scgp, f, device, &schilly_bus, &target, &lun)) {
-					(++(*nopen));
-				} else {
-					close(f);
+						   "errno (EACCESS), you don't have the needed rights for %s\n",
+						   device);
 				}
+				js_fprintf((FILE *) scgp->errfile,
+					   "try open(%s) return %i, errno %i, trying next cdrom\n",
+					   device, f, errno);
 			}
-		}
-	}
-	if (!DEVFS) {
-		/* for /dev/sr0 - /dev/sr? */
-		for (i = 0; ; i++) {
-			sprintf(device, "/dev/sr%i", i);
-			if ((f = open(device, O_RDONLY | O_NONBLOCK)) < 0) {
-				if (errno != ENOENT && errno != ENXIO && errno != ENODEV && errno != EACCES) {
-					if (scgp->debug > 4) {
-						js_fprintf((FILE *) scgp->errfile,
-						"try open(%s) return %i, errno %i, cancel\n",
-						device, f, errno);
-					}
-					return (-2);
-				} else if (errno == ENOENT || errno == ENODEV) {
-					break;
-				}
-			} else {
-				if (sg_amapdev(scgp, f, device, &schilly_bus, &target, &lun)) {
-					(++(*nopen));
-				} else {
-					close(f);
-				}
+		} else {
+			if (scgp->debug > 4) {
+				js_fprintf((FILE *) scgp->errfile,
+					   "try open(%s) return %i errno %i calling sg_mapdev(...)\n",
+					   device, f, errno);
 			}
-		}
-
-		/* for /dev/hda - /dev/hdz */
-		for (i = 'a'; i <= 'z'; i++) {
-			sprintf(device, "/dev/hd%c", i);
-			if ((f = open(device, O_RDONLY | O_NONBLOCK)) < 0) {
-				if (errno != ENOENT && errno != ENXIO && errno != EACCES) {
-					if (scgp->debug > 4) {
-						js_fprintf((FILE *) scgp->errfile,
-						"try open(%s) return %i, errno %i, cancel\n",
-						device, f, errno);
-					}
-					return (-2);
-				} else if (errno == ENOENT || errno == ENODEV) {
-					break;
-				}
+			if (sg_amapdev(scgp, f, device, &schilly_bus, &target, &lun)) {
+				(++(*nopen));
 			} else {
-				/* ugly hack, make better, when you can. Alex */
-				if (0 > ioctl(f, CDROM_DRIVE_STATUS, CDSL_CURRENT)) {
-					if (scgp->debug > 4) {
-						js_fprintf((FILE *) scgp->errfile,
-						"%s is not a cdrom, skipping\n",
-						device);
-					}
-					close(f);
-				} else if (sg_amapdev(scgp, f, device, &schilly_bus, &target, &lun)) {
-					(++(*nopen));
-				} else {
-					close(f);
-				}
+				close(f);
 			}
 		}
 	}
+	globfree(&globbuf);
 	return (0);
 }
 
--- scsilib/libscg/scsi-linux-pg.c.scan	2004-01-15 01:54:36.000000000 +0100
+++ scsilib/libscg/scsi-linux-pg.c	2004-09-22 12:59:04.107815600 +0200
@@ -130,6 +130,8 @@
 	return (0);
 }
 
+#include <glob.h>
+
 LOCAL int
 scgo_open(scgp, device)
 	SCSI	*scgp;
@@ -146,6 +148,8 @@
 #endif
 	register int	nopen = 0;
 	char		devname[32];
+        glob_t globbuf;
+        int i;
 
 	if (busno >= MAX_SCG || tgt >= MAX_TGT || tlun >= MAX_LUN) {
 		errno = EINVAL;
@@ -217,10 +221,14 @@
 		scglocal(scgp)->scgfiles[busno][tgt][tlun] = f;
 		return (1);
 	} else {
+		const char *dev;
 		tlun = 0;
-		for (tgt = 0; tgt < MAX_TGT; tgt++) {
-			js_snprintf(devname, sizeof (devname), "/dev/pg%d", tgt);
-			f = open(devname, O_RDWR | O_NONBLOCK);
+		glob("/dev/pg[0-9]", GLOB_NOSORT, NULL, &globbuf);
+		glob("/dev/pg[0-9][0-9]", GLOB_NOSORT|GLOB_APPEND, NULL, &globbuf);
+		for (i = 0; globbuf.gl_pathv && globbuf.gl_pathv[i] != NULL ; i++) {
+		        dev = globbuf.gl_pathv[i];
+			tgt = atoi(&dev[7]);
+			f = open(dev, O_RDWR | O_NONBLOCK);
 			if (f < 0) {
 				/*
 				 * Set up error string but let us clear it later
@@ -232,7 +240,8 @@
 				if (errno != ENOENT && errno != ENXIO && errno != ENODEV) {
 					if (scgp->errstr)
 						js_snprintf(scgp->errstr, SCSI_ERRSTR_SIZE,
-							"Cannot open '%s'", devname);
+							"Cannot open '%s'", dev);
+					globfree(&globbuf);
 					return (0);
 				}
 			} else {
@@ -240,6 +249,8 @@
 				nopen++;
 			}
 		}
+		globfree(&globbuf);
+
 	}
 	if (nopen > 0 && scgp->errstr)
 		scgp->errstr[0] = '\0';
